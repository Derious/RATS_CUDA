
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "cephes.h"
#include "rats.h"

#define SQRT2		1.41421356237309504880

const unsigned char BinaryDerivative_4bitxortab[16] = { 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0 };
const unsigned char BinaryDerivative_8bitxortab[256] = {
	0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0,
	0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1,
	0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1,
	0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0,
	0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1,
	0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0,
	0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0,
	0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1,
	0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1,
	0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0,
	0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0,
	0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1,
	0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0,
	0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1,
	0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1,
	0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0
};

unsigned short BinaryDerivative_7Table[512] = {
	0x0F8, 0x1FA, 0x1FC, 0x0FA, 0x1FE, 0x0FC, 0x0FA, 0x1FC, 0x100, 0x0FE, 0x0FC, 0x1FE, 0x0FA, 0x1FC, 0x1FE, 0x0FC,
	0x102, 0x000, 0x0FE, 0x100, 0x0FC, 0x1FE, 0x100, 0x0FE, 0x0FA, 0x1FC, 0x1FE, 0x0FC, 0x100, 0x0FE, 0x0FC, 0x1FE,
	0x104, 0x002, 0x000, 0x102, 0x0FE, 0x100, 0x102, 0x000, 0x0FC, 0x1FE, 0x100, 0x0FE, 0x102, 0x000, 0x0FE, 0x100,
	0x0FA, 0x1FC, 0x1FE, 0x0FC, 0x100, 0x0FE, 0x0FC, 0x1FE, 0x102, 0x000, 0x0FE, 0x100, 0x0FC, 0x1FE, 0x100, 0x0FE,
	0x106, 0x004, 0x002, 0x104, 0x000, 0x102, 0x104, 0x002, 0x0FE, 0x100, 0x102, 0x000, 0x104, 0x002, 0x000, 0x102,
	0x0FC, 0x1FE, 0x100, 0x0FE, 0x102, 0x000, 0x0FE, 0x100, 0x104, 0x002, 0x000, 0x102, 0x0FE, 0x100, 0x102, 0x000,
	0x0FA, 0x1FC, 0x1FE, 0x0FC, 0x100, 0x0FE, 0x0FC, 0x1FE, 0x102, 0x000, 0x0FE, 0x100, 0x0FC, 0x1FE, 0x100, 0x0FE,
	0x104, 0x002, 0x000, 0x102, 0x0FE, 0x100, 0x102, 0x000, 0x0FC, 0x1FE, 0x100, 0x0FE, 0x102, 0x000, 0x0FE, 0x100,
	0x108, 0x006, 0x004, 0x106, 0x002, 0x104, 0x106, 0x004, 0x000, 0x102, 0x104, 0x002, 0x106, 0x004, 0x002, 0x104,
	0x0FE, 0x100, 0x102, 0x000, 0x104, 0x002, 0x000, 0x102, 0x106, 0x004, 0x002, 0x104, 0x000, 0x102, 0x104, 0x002,
	0x0FC, 0x1FE, 0x100, 0x0FE, 0x102, 0x000, 0x0FE, 0x100, 0x104, 0x002, 0x000, 0x102, 0x0FE, 0x100, 0x102, 0x000,
	0x106, 0x004, 0x002, 0x104, 0x000, 0x102, 0x104, 0x002, 0x0FE, 0x100, 0x102, 0x000, 0x104, 0x002, 0x000, 0x102,
	0x0FA, 0x1FC, 0x1FE, 0x0FC, 0x100, 0x0FE, 0x0FC, 0x1FE, 0x102, 0x000, 0x0FE, 0x100, 0x0FC, 0x1FE, 0x100, 0x0FE,
	0x104, 0x002, 0x000, 0x102, 0x0FE, 0x100, 0x102, 0x000, 0x0FC, 0x1FE, 0x100, 0x0FE, 0x102, 0x000, 0x0FE, 0x100,
	0x106, 0x004, 0x002, 0x104, 0x000, 0x102, 0x104, 0x002, 0x0FE, 0x100, 0x102, 0x000, 0x104, 0x002, 0x000, 0x102,
	0x0FC, 0x1FE, 0x100, 0x0FE, 0x102, 0x000, 0x0FE, 0x100, 0x104, 0x002, 0x000, 0x102, 0x0FE, 0x100, 0x102, 0x000,
	0x108, 0x006, 0x004, 0x106, 0x002, 0x104, 0x106, 0x004, 0x000, 0x102, 0x104, 0x002, 0x106, 0x004, 0x002, 0x104,
	0x0FE, 0x100, 0x102, 0x000, 0x104, 0x002, 0x000, 0x102, 0x106, 0x004, 0x002, 0x104, 0x000, 0x102, 0x104, 0x002,
	0x0FC, 0x1FE, 0x100, 0x0FE, 0x102, 0x000, 0x0FE, 0x100, 0x104, 0x002, 0x000, 0x102, 0x0FE, 0x100, 0x102, 0x000,
	0x106, 0x004, 0x002, 0x104, 0x000, 0x102, 0x104, 0x002, 0x0FE, 0x100, 0x102, 0x000, 0x104, 0x002, 0x000, 0x102,
	0x0FA, 0x1FC, 0x1FE, 0x0FC, 0x100, 0x0FE, 0x0FC, 0x1FE, 0x102, 0x000, 0x0FE, 0x100, 0x0FC, 0x1FE, 0x100, 0x0FE,
	0x104, 0x002, 0x000, 0x102, 0x0FE, 0x100, 0x102, 0x000, 0x0FC, 0x1FE, 0x100, 0x0FE, 0x102, 0x000, 0x0FE, 0x100,
	0x106, 0x004, 0x002, 0x104, 0x000, 0x102, 0x104, 0x002, 0x0FE, 0x100, 0x102, 0x000, 0x104, 0x002, 0x000, 0x102,
	0x0FC, 0x1FE, 0x100, 0x0FE, 0x102, 0x000, 0x0FE, 0x100, 0x104, 0x002, 0x000, 0x102, 0x0FE, 0x100, 0x102, 0x000,
	0x0F8, 0x1FA, 0x1FC, 0x0FA, 0x1FE, 0x0FC, 0x0FA, 0x1FC, 0x100, 0x0FE, 0x0FC, 0x1FE, 0x0FA, 0x1FC, 0x1FE, 0x0FC,
	0x102, 0x000, 0x0FE, 0x100, 0x0FC, 0x1FE, 0x100, 0x0FE, 0x0FA, 0x1FC, 0x1FE, 0x0FC, 0x100, 0x0FE, 0x0FC, 0x1FE,
	0x104, 0x002, 0x000, 0x102, 0x0FE, 0x100, 0x102, 0x000, 0x0FC, 0x1FE, 0x100, 0x0FE, 0x102, 0x000, 0x0FE, 0x100,
	0x0FA, 0x1FC, 0x1FE, 0x0FC, 0x100, 0x0FE, 0x0FC, 0x1FE, 0x102, 0x000, 0x0FE, 0x100, 0x0FC, 0x1FE, 0x100, 0x0FE,
	0x106, 0x004, 0x002, 0x104, 0x000, 0x102, 0x104, 0x002, 0x0FE, 0x100, 0x102, 0x000, 0x104, 0x002, 0x000, 0x102,
	0x0FC, 0x1FE, 0x100, 0x0FE, 0x102, 0x000, 0x0FE, 0x100, 0x104, 0x002, 0x000, 0x102, 0x0FE, 0x100, 0x102, 0x000,
	0x0FA, 0x1FC, 0x1FE, 0x0FC, 0x100, 0x0FE, 0x0FC, 0x1FE, 0x102, 0x000, 0x0FE, 0x100, 0x0FC, 0x1FE, 0x100, 0x0FE,
	0x104, 0x002, 0x000, 0x102, 0x0FE, 0x100, 0x102, 0x000, 0x0FC, 0x1FE, 0x100, 0x0FE, 0x102, 0x000, 0x0FE, 0x100,
};


//void BinaryDerivative_Init7tab()
//{
//	FILE *fp1;
//	if ((fp1 = fopen("tempfile/BinaryDerivative7TableLastbit.cpp", "w")) == NULL)
//	{
//		printf("cannot open file!/n");
//		exit(0);
//	}
//	FILE *fp2;
//	if ((fp2 = fopen("tempfile/BinaryDerivative7TableS.cpp", "w")) == NULL)
//	{
//		printf("cannot open file!/n");
//		exit(0);
//	}
//
//	fprintf(fp1, "unsigned char BinaryDerivative_7TableLastbit[512]={\n");
//	fprintf(fp2, "int BinaryDerivative_7TableS[512]={\n");
//
//	for (int i = 0; i < 512; i++)
//	{
//		unsigned char t = i & 0xff;
//		unsigned char A = (i >> 8) & 0xff;
//		int S = 0;
//		unsigned char a = A;
//		for (int j = 0; j < 8; j++)
//		{
//			a ^= ((t & 0x80) >> 7);//a(i) = a(i-1) ^ t(i)
//
//			if (a & 0x1)//如果这一位算出来是1
//			{
//				S++;//计1数量++
//			}
//			else 
//			{
//				S--;
//			}
//
//			t <<= 1;
//		}
//
//		//unsigned short pair = S + (a << 8);
//		fprintf(fp1, "0x%02X, ", a);
//		fprintf(fp2, "%d, ", S);
//		if (i % 16 == 15)
//		{
//			fprintf(fp1, "\n");
//			fprintf(fp2, "\n");
//		}
//	}
//
//	fprintf(fp1, "};\n\n");
//	fprintf(fp2, "};\n\n");
//	fclose(fp1);
//	fclose(fp2);
//}
//
//void BinaryDerivative_Init7tab()
//{
//	FILE *fp;
//	if ((fp = fopen("tempfile/BinaryDerivative7Table.cpp", "w")) == NULL)
//	{
//		printf("cannot open file!/n");
//		exit(0);
//	}
//
//	fprintf(fp, "unsigned short BinaryDerivative_7Table[512]={\n");
//
//	for (int i = 0; i < 512; i++)
//	{
//		unsigned char t = i & 0xff;
//		unsigned char A = (i >> 8) & 0xff;
//		char S = 0;
//		unsigned char a = A;
//		for (int j = 0; j < 8; j++)
//		{
//			a ^= ((t & 0x80) >> 7);//a(i) = a(i-1) ^ t(i)
//			//printf("%X\n", a);
//
//			if (a & 0x1)//如果这一位算出来是1
//			{
//				S++;//计1数量++
//			}
//			else
//			{
//				S--;
//			}
//
//			t <<= 1;
//		}
//		printf("%X   %d\n", a, S);
//		unsigned short pair = S & 0xff + ((unsigned short)a << 8);
//		fprintf(fp, "0x%04X, ", pair);
//
//		if (i % 16 == 15)
//		{
//			fprintf(fp, "\n");
//		}
//	}
//
//	fprintf(fp, "};\n\n");
//
//	fclose(fp);
//}
//
//void BinaryDerivative_Init3tab()
//{
//	FILE *fp;
//	if ((fp = fopen("tempfile/BinaryDerivative3Table.cpp", "w")) == NULL)
//	{
//		printf("cannot open file!/n");
//		exit(0);
//	}
//
//	fprintf(fp, "unsigned short BinaryDerivative_3Table[512]={\n");
//
//	for (int i = 0; i < 512; i++)
//	{
//		unsigned char t = i & 0xff;
//		unsigned char A = (i >> 8) & 0xff;
//		char S = 0;
//		unsigned char a = A;
//		for (int j = 0; j < 8; j++)
//		{
//			a ^= ((t & 0x80) >> 7);//a(i) = a(i-1) ^ t(i)
//			//printf("%X\n", a);
//
//			if (a & 0x1)//如果这一位算出来是1
//			{
//				S++;//计1数量++
//			}
//			else
//			{
//				S--;
//			}
//
//			t <<= 1;
//		}
//		//printf("%X   %d\n", a, S);
//		unsigned short pair = S & 0xff + ((unsigned short)a << 8);
//		fprintf(fp, "0x%04X, ", pair);
//
//		if (i % 16 == 15)
//		{
//			fprintf(fp, "\n");
//		}
//	}
//
//	fprintf(fp, "};\n\n");
//
//	fclose(fp);
//}

void BinaryDerivative_CalS_3(unsigned char *data, int bits, int *S)
{
	int i;
	int len = bits / 8;
	int s = 0;
	int index0, pos0, index4, pos4;

	unsigned char tmp = (data[0] >> 4) & 0xf;
	unsigned char a = BinaryDerivative_4bitxortab[tmp];
	s += a == 0 ? -1 : 1;

	unsigned char a0, a4;
	for (i = 0; i + 4 < bits; i++)
	{
		index0 = i / 8;
		pos0 = i % 8;
		index4 = (i + 4) / 8;
		pos4 = (i + 4) % 8;
		a0 = (data[index0] >> (7 - pos0)) & 0x1;
		a4 = (data[index4] >> (7 - pos4)) & 0x1;
		a = a ^ a0 ^ a4;
		s += a == 0 ? -1 : 1;
	}
	*S = s;
}

void BinaryDerivative_CalS_7(unsigned char *data, int bits, int *S)
{
	union
	{
		struct
		{
			unsigned char t;
			unsigned char A;
		}sti;
		unsigned short index;
	} input;
	union
	{
		struct
		{
			char S;
			unsigned char lb;
		}sto;
		unsigned short result;
	} output;

	int len_data = bits / 8;
	int len_t = len_data - 1;

	unsigned char *t = (unsigned char *)malloc(len_data * sizeof(unsigned char));

	for (int i = 0; i < len_t; i++)
	{
		t[i] = data[i] ^ data[i + 1];
	}

	//构成第一个查询下标input.index = input.sti.A || input.sti.t
	input.sti.A = BinaryDerivative_8bitxortab[data[0]];//计算a(-1)，或者说A，取x[0]的前8位异或为a(-1)，查表可得
	input.sti.t = t[0];//取t[0]

	//累加S
	*S += input.sti.A == 0 ? -1 : 1;//先加上，1则加1，0则减1
	for (int i = 0; i < len_t;)
	{
		output.result = BinaryDerivative_7Table[input.index];//查表
		*S += output.sto.S;//计重

		input.sti.A = output.sto.lb;//准备下一次查表的前8位（最后一位a(i)=lb
		input.sti.t = t[++i];//准备下一次查表的后8位（8位的t
	}
}

//void BinaryDerivative_CalS_3(unsigned char *data, int bits, int &S)
//{
//	union
//	{
//		struct
//		{
//			unsigned char t;
//			unsigned char A;
//		}sti;
//		unsigned short index;
//	} input;
//	union
//	{
//		struct
//		{
//			char S;
//			unsigned char lb;
//		}sto;
//		unsigned short result;
//	} output;
//
//	int len_data = bits / 8;
//	int len_t = len_data;
//
//	unsigned char *t = (unsigned char *)malloc(len_data * sizeof(unsigned char));
//	unsigned char *data_shl4 = (unsigned char *)malloc(len_data * sizeof(unsigned char));
//
//	//计算x_[]，为x[]左移4bit所得
//	memset(data_shl4, 0, len_data);
//	for (int i = 0; i < len_data; i++)
//	{
//		data_shl4[i] = data[i] << 4;
//		if (i != len_data - 1)//前三个接头处
//		{
//			data_shl4[i] ^= (data[i + 1] & 0xf0) >> 4;
//		}
//	}
//
//	for (int i = 0; i < len_t; i++)
//	{
//		t[i] = data[i] ^ data_shl4[i];
//	}
//
//	//构成第一个查询下标input.index = input.sti.A || input.sti.t
//	input.sti.A = BinaryDerivative_4bitxortab[(data[0] >> 4) & 0xf];//计算a(-1)，或者说A，取x[0]的前8位异或为a(-1)，查表可得
//	input.sti.t = t[0];//取t[0]
//
//	//累加S
//	S += input.sti.A == 0 ? -1 : 1;//先加上，1则加1，0则减1
//	//最后4bit先不做
//	for (int i = 0; i < len_t - 1;)
//	{
//		output.result = BinaryDerivative_7Table[input.index];//查表
//		S += output.sto.S;//计重
//
//		input.sti.A = output.sto.lb;//准备下一次查表的前8位（最后一位a(i)=lb
//		input.sti.t = t[++i];//准备下一次查表的后8位（8位的t
//	}
//	//处理最后4bit
//	unsigned char a = input.sti.A;
//	unsigned char next4 = t[len_t - 1];
//
//	for (int i = 0; i < 4; i++)
//	{
//		a ^= ((next4 & 0x80) >> 7);
//		if (a & 0x1)//如果这一位算出来是1
//		{
//			S++;//计1数量++
//		}
//		else
//		{
//			S--;
//		}
//
//		next4 <<= 1;
//	}
//}

#ifndef GET_EPSILON
#define GET_EPSILON(d, i)	(((d)[(i) / 8] >> (7 - (i) % 8)) & 1)
#endif // !GET_EPSILON

static const unsigned char ratsTable8_Hamming[256] = {
	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,		//0000-XXXX
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,		//0001-XXXX
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,		//0010-XXXX
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,		//0011-XXXX
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,		//0100-XXXX
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,		//0101-XXXX
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,		//0110-XXXX
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,		//0111-XXXX
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,		//1000-XXXX
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,		//1001-XXXX
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,		//1010-XXXX
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,		//1011-XXXX
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,		//1100-XXXX
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,		//1101-XXXX
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,		//1110-XXXX
	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8		//1111-XXXX
};

//Get the binary_derivative frequency
int rats_get_binary_derivative(unsigned char *data, int n, int k)
{
	unsigned int comb_bin[8] = {
		0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF
	};
	int i, p, block;
	int S = 0;

	if (k < 0 || k > 8)
	{
		return 0;
	}
	if (k == 0)
	{
		p = n / 8;
		for (i = 0; i < p; i++)
			S += ratsTable8_Hamming[data[i]];
		if (p = n % 8)
			S += ratsTable8_Hamming[data[i] >> (8 - p)];
		return S;
	}

	//Step-1: Get last 32-bit
	if (n % 8)
	{
		i = n / 8 - 4;
		block = (unsigned int)data[i] << 24 | (unsigned int)data[i + 1] << 16 | (unsigned int)data[i + 2] << 8 | (unsigned int)data[i + 3];
		block = (block << (n % 8)) | ((unsigned int)data[i + 1] >> (8 - (n % 8)));
	}
	else
	{
		i = n / 8 - 4;
		block = (unsigned int)data[i] << 24 | (unsigned int)data[i + 1] << 16 | (unsigned int)data[i + 2] << 8 | (unsigned int)data[i + 3];
	}

	//Step-2: Get blocks count
	p = comb_bin[k];
	for (i = 0; i < k; i++)//Skip k bit
	{
		block = (block << 1) + GET_EPSILON(data, i);
	}
	for ( ; i < n; i++)
	{
		block = (block << 1) + GET_EPSILON(data, i);
		S += ratsTable8_Hamming[block & p] & 1;
	}

	return (2 * S - (n - k));
}

int BinaryDerivative(double alpha, unsigned char *data, int bits, int k, BinaryDerivative_V *value)
{
	double p_value, v_obs;
	int S = 0, B;
	int n;

	//Step 1: Check input size
	if ((n = bits) < 100)
		return -1;//Error: Input size error.
	if (k < 0 || k > 31)
		return -1;//Error: Input size error.

	//Step 2: Get statistic
	switch (k)
	{
	case 3:
		BinaryDerivative_CalS_3(data, n, &S);
		break;
	case 7:
		BinaryDerivative_CalS_7(data, n, &S);
		break;
	default :
		return -1;
	}
	v_obs = fabs((double)S) / sqrt((double)(n - k));
	p_value = erfc(v_obs / SQRT2);

	B = rats_get_binary_derivative(data, n, k);
	v_obs = fabs((double)B) / sqrt((double)(n - k));
	p_value = erfc(v_obs / SQRT2);

	if (value)
	{
		value->sum = S;
		value->v_obs = v_obs;
		value->p_value = p_value;
	}

	//Step 3: Decision
	if (p_value < alpha)
		return 0;//未通过
	return 1;//通过
}

void BinaryDerivative_demo()
{
	unsigned char a[] = { 0x5f, 0x79 };
	//unsigned char a[] = { 0x5f,0x79,0x63,0xd8,0x87,0x40,0x8a,0x9d,0xc2,0x4a,0xa8,0xe3,0x94,0x1f, 0x7f, 0x88, 0xca };
	//unsigned char a[] = "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
	//unsigned char a[] = "erq823alsfjqo;wjfao;eiufalsfj;lsdfwr632/rwaw4rqur88 qwfo lofjqwo;-3=\"2wef]qwfqwr";

	//BinaryDerivative_P param;
	//param.k = 7;
	BinaryDerivative(0, a, (sizeof(a)) * 8, 7, NULL);

	int S;
	S = 0;
	BinaryDerivative_CalS_7(a, (sizeof(a)) * 8, &S);
	printf("S = %d\n", S);
	S = 0;
	BinaryDerivative_CalS_3(a, (sizeof(a)) * 8, &S);
	printf("S = %d\n", S);
}

//int main()
//{
//	//BinaryDerivative_Init3tab();
//	BinaryDerivative_demo();
//	system("pause");
//	return 0;
//}
